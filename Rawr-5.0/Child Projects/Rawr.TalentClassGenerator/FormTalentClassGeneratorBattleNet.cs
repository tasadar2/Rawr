using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.Xml;
using System.Globalization;
using System.Text.RegularExpressions;


// AS OF 04/10/2011:
// - THE LATEST 4.1.0 BUILD (UNRELEASED PATCH) IS 13726
// - THE LATEST LIVE BUILD IS 13623 according to wow client


namespace Rawr.TalentClassGenerator
{
    public partial class FormTalentClassGeneratorBattleNet : Form
    {
        public FormTalentClassGeneratorBattleNet()
        {
            InitializeComponent();
        }

        private void buttonGenerateCode_Click(object sender, EventArgs e)
        {
            textBoxCode.Text = @"using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace Rawr
{
	/// <summary>
	/// This file is automatically generated by the Rawr.TalentClassGenerator tool. Please don't edit it directly.
	/// </summary>
	[AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
	public sealed class TalentDataAttribute : Attribute
	{
		public TalentDataAttribute(int index, string name, int maxPoints, int tree, int column, int row, int prerequisite, string[] description, string icon)
		{
			_index = index;
			_name = name;
			_maxPoints = maxPoints;
			_tree = tree;
			_column = column;
			_row = row;
			_prerequisite = prerequisite;
			_description = description;
			_icon = icon;
		}

		private readonly int _index;
		private readonly string _name;
		private readonly int _maxPoints;
		private readonly int _tree;
		private readonly int _column;
		private readonly int _row;
		private readonly int _prerequisite;
		private readonly string _icon;
		private readonly string[] _description;

		public int Index { get { return _index; } }
		public string Name { get { return _name; } }
		public int MaxPoints { get { return _maxPoints; } }
		public int Tree { get { return _tree; } }
		public int Column { get { return _column; } }
		public int Row { get { return _row; } }
		public int Prerequisite { get { return _prerequisite; } }
		public string[] Description { get { return _description; } }
		public string Icon { get { return _icon; } }
	}

	public abstract class TalentsBase
	{
		public abstract int[] Data { get; }
		public virtual bool[] GlyphData { get { return null; } }
        //
        public virtual int TreeStartingIndexes_0 { get { return 0; } }
        public virtual int TreeStartingIndexes_1 { get { return 0; } }
        public virtual int TreeStartingIndexes_2 { get { return 0; } }
        public int[] TreeStartingIndexes { get { return new int[] { TreeStartingIndexes_0, TreeStartingIndexes_1, TreeStartingIndexes_2 }; } }
        public int[] TreeLengths {
            get {
                return new int[] {
                    TreeStartingIndexes_1,
                    TreeStartingIndexes_2 - TreeStartingIndexes_1,
                    Data.Length - TreeStartingIndexes_2,
                };
            }
        }
        public virtual int GlyphTreeStartingIndexes_0 { get { return 0; } }
        public virtual int GlyphTreeStartingIndexes_1 { get { return 0; } }
        public virtual int GlyphTreeStartingIndexes_2 { get { return 0; } }
        public int[] GlyphTreeStartingIndexes { get { return new int[] { GlyphTreeStartingIndexes_0, GlyphTreeStartingIndexes_1, GlyphTreeStartingIndexes_2 }; } }
        public int[] GlyphTreeLengths {
            get {
                return new int[] {
                    GlyphTreeStartingIndexes_1,
                    GlyphTreeStartingIndexes_2 - GlyphTreeStartingIndexes_1,
                    GlyphData.Length - GlyphTreeStartingIndexes_2,
                };
            }
        }
        public int[] treeCounts = { -1, -1, -1 };
        public int[] glyphtreeCounts = { -1, -1, -1 };
        //
        public int[] TreeCounts
        {
            get
            {
                if (treeCounts[0] == -1)
                {
                    treeCounts[0] = 0;
                    for (int i = TreeStartingIndexes[0]; i < TreeStartingIndexes[1]; i++)
                    {
                        treeCounts[0] += Data[i];
                    }
                }
                if (treeCounts[1] == -1)
                {
                    treeCounts[1] = 0;
                    for (int i = TreeStartingIndexes[1]; i < TreeStartingIndexes[2]; i++)
                    {
                        treeCounts[1] += Data[i];
                    }
                }
                if (treeCounts[2] == -1)
                {
                    treeCounts[2] = 0;
                    for (int i = TreeStartingIndexes[2]; i < Data.Length; i++)
                    {
                        treeCounts[2] += Data[i];
                    }
                }
                return treeCounts;
            }
            protected set { treeCounts = value; }
        }
        public int[] GlyphTreeCounts
        {
            get
            {
                if (glyphtreeCounts[0] == -1)
                {
                    glyphtreeCounts[0] = 0;
                    for (int i = GlyphTreeStartingIndexes[0]; i < GlyphTreeStartingIndexes[1]; i++)
                    {
                        glyphtreeCounts[0] += GlyphData[i] ? 1 : 0;
                    }
                }
                if (glyphtreeCounts[1] == -1)
                {
                    glyphtreeCounts[1] = 0;
                    for (int i = GlyphTreeStartingIndexes[1]; i < GlyphTreeStartingIndexes[2]; i++)
                    {
                        glyphtreeCounts[1] += GlyphData[i] ? 1 : 0;
                    }
                }
                if (glyphtreeCounts[2] == -1)
                {
                    glyphtreeCounts[2] = 0;
                    for (int i = GlyphTreeStartingIndexes[2]; i < GlyphData.Length; i++)
                    {
                        glyphtreeCounts[2] += GlyphData[i] ? 1 : 0;
                    }
                }
                return glyphtreeCounts;
            }
            protected set { glyphtreeCounts = value; }
        }
        //
        public int HighestTree
        {
            get
            {
                int[] trees = TreeCounts;
                if (trees[0] >= trees[1] && trees[0] >= trees[2]) { return 0; }
                if (trees[1] >= trees[0] && trees[1] >= trees[2]) { return 1; }
                if (trees[2] >= trees[0] && trees[2] >= trees[1]) { return 2; }
                return 0;
            }
        }
        //
        protected void LoadString(string code, int[][] glyphEncodes=null)
        {
            if (string.IsNullOrEmpty(code)) return;
            int[] _data = Data;
            string[] tmp = code.Split('.');
            string talents = tmp[0];
            if (talents.Length >= _data.Length)
            {
                List<int> data = new List<int>();
                foreach (Char digit in talents)
                    data.Add(int.Parse(digit.ToString()));
                data.CopyTo(0, _data, 0, _data.Length);
            }
            if (tmp.Length > 1)
            {
                string glyphs = tmp[1];
                bool[] _glyphData = GlyphData;
                if (_glyphData != null && glyphs.Length == _glyphData.Length)
                {
                    List<bool> data = new List<bool>();
                    foreach (Char digit in glyphs)
                        data.Add(int.Parse(digit.ToString()) == 1);
                    data.CopyTo(_glyphData);
                }
            } else if (glyphEncodes != null) {
                // This makes it determine the glyphs active from WowHead Glyph IDs
                // (numbered as [0-2][0-5]), see TalentPicker.xaml.cs for details
                bool[] _glyphData = GlyphData;
                if (_glyphData != null) {
                    List<GlyphDataAttribute> glyphsInOrder_Prime = new List<GlyphDataAttribute>();
                    List<GlyphDataAttribute> glyphsInOrder_Major = new List<GlyphDataAttribute>();
                    List<GlyphDataAttribute> glyphsInOrder_Minor = new List<GlyphDataAttribute>();
                    foreach (PropertyInfo pi in this.GetType().GetProperties()) {
                        GlyphDataAttribute[] glyphDatas = pi.GetCustomAttributes(typeof(GlyphDataAttribute), true) as GlyphDataAttribute[];
                        if (glyphDatas.Length > 0) {
                            if      (glyphDatas[0].Type == GlyphType.Prime) { glyphsInOrder_Prime.Add(glyphDatas[0]); }
                            else if (glyphDatas[0].Type == GlyphType.Major) { glyphsInOrder_Major.Add(glyphDatas[0]); }
                            else if (glyphDatas[0].Type == GlyphType.Minor) { glyphsInOrder_Minor.Add(glyphDatas[0]); }
                        }
                    }
                    glyphsInOrder_Prime.Sort(CompareGlyphsById);
                    glyphsInOrder_Major.Sort(CompareGlyphsById);
                    glyphsInOrder_Minor.Sort(CompareGlyphsById);
                    int counter = 0;
                    for (int i = 0; i < glyphsInOrder_Prime.Count; i++)
                    {
                        for (int e = 0; e < 3; e++)
                        {
                            if (counter == glyphEncodes[0][e]) { _glyphData[glyphsInOrder_Prime[i].Index] = true; break; }
                        }
                        // Iterate Counter, but we can't do 6-9 of any 10 block
                        counter++;
                        if (counter == 6 || counter == 16 || counter == 26) { counter -= 6; counter += 10; }
                    }
                }
            }
        }

        private static int CompareGlyphsById(GlyphDataAttribute x, GlyphDataAttribute y) {
            if (x == null) {
                if (y == null) {
                    // If x is null and y is null, they're equal
                    return 0;
                } else {
                    // If x is null and y is not null, y is greater
                    return -1;
                }
            } else {
                // If x is not null...
                if (y == null) { // ...and y is null, x is greater.
                    return 1;
                } else {
                    // sort them with ordinary string comparison.
                    return x.SpellID.CompareTo(y.SpellID);
                }
            }
        }
        //
		public override string ToString()
		{
			StringBuilder ret = new StringBuilder();
			foreach (int digit in Data)
				ret.Append(digit.ToString());
			if (GlyphData != null)
			{
				ret.Append('.');
				foreach (bool glyph in GlyphData)
				{
					ret.Append(glyph ? '1' : '0');
				}
			}
			return ret.ToString();
		}

		public CharacterClass GetClass()
		{
			if (GetType() == typeof(WarlockTalents)) return CharacterClass.Warlock;
			if (GetType() == typeof(MageTalents)) return CharacterClass.Mage;
			if (GetType() == typeof(PriestTalents)) return CharacterClass.Priest;
			if (GetType() == typeof(DruidTalents)) return CharacterClass.Druid;
			if (GetType() == typeof(RogueTalents)) return CharacterClass.Rogue;
			if (GetType() == typeof(HunterTalents)) return CharacterClass.Hunter;
			if (GetType() == typeof(ShamanTalents)) return CharacterClass.Shaman;
			if (GetType() == typeof(DeathKnightTalents)) return CharacterClass.DeathKnight;
			if (GetType() == typeof(PaladinTalents)) return CharacterClass.Paladin;
			return CharacterClass.Warrior;
		}

		public abstract TalentsBase Clone();
	}

";
            List<ClassData> classes = new List<ClassData>();
            classes.Add(new ClassData()
            {
                ID = 1,
                Name = "Warrior",
                TreeNames = new string[] { "Warrior" },
                TreeIDs = new string[] { "1" }
            });
            classes.Add(new ClassData()
            {
                ID = 2,
                Name = "Paladin",
                TreeNames = new string[] { "Paladin" },
                TreeIDs = new string[] { "2" }
            });
            classes.Add(new ClassData()
            {
                ID = 3,
                Name = "Hunter",
                TreeNames = new string[] { "Hunter" },
                TreeIDs = new string[] { "3" }
            });
            classes.Add(new ClassData()
            {
                ID = 4,
                Name = "Rogue",
                TreeNames = new string[] { "Rogue" },
                TreeIDs = new string[] { "4" }
            });
            classes.Add(new ClassData()
            {
                ID = 5,
                Name = "Priest",
                TreeNames = new string[] { "Priest" },
                TreeIDs = new string[] { "5" }
            });
            classes.Add(new ClassData()
            {
                ID = 6,
                Name = "DeathKnight",
                TreeNames = new string[] { "Death Knight" },
                TreeIDs = new string[] { "6" }
            });
            classes.Add(new ClassData()
            {
                ID = 7,
                Name = "Shaman",
                TreeNames = new string[] { "Shaman" },
                TreeIDs = new string[] { "7" }
            });
            classes.Add(new ClassData()
            {
                ID = 8,
                Name = "Mage",
                TreeNames = new string[] { "Mage" },
                TreeIDs = new string[] { "8" }
            });
            classes.Add(new ClassData()
            {
                ID = 9,
                Name = "Warlock",
                TreeNames = new string[] { "Warlock" },
                TreeIDs = new string[] { "9" }
            });
            classes.Add(new ClassData()
            {
                ID = 11,
                Name = "Druid",
                TreeNames = new string[] { "Druid" },
                TreeIDs = new string[] { "11" }
            });



            //for (int i = 0; i < classId.Length; i++)
            foreach (ClassData classData in classes)
            {
                string read = "";
                try
                {
                    ProcessTalentDataJSON(read = new StreamReader(System.Net.HttpWebRequest.Create(
                        string.Format("http://us.battle.net/wow/en/game/mists-of-pandaria/feature/talent-calculator.frag?class={0}",
                        classData.ID)).GetResponse().GetResponseStream()).ReadToEnd(), classData);
                }
                catch (Exception ex)
                {
                    textBoxCode.Text = "FAILED on: " + classData.Name + " : " + ex.Message + "\r\n\r\n" + ex.StackTrace + "\r\n\r\n" + read;
                    return;
                }
            }
            textBoxCode.Text += "}\r\n";
            textBoxCode.SelectAll();
            textBoxCode.Focus();
        }

        private void ProcessTalentDataJSON(string fullResponse, ClassData classData)
        {
            List<TalentData> talents = new List<TalentData>();
            string allTalentsData = fullResponse.Between("\"talents\":[[", "]]});");
            // Use a regex to match all the spell data
            MatchCollection coll = Regex.Matches(allTalentsData, "{\"spell\":{.*?}.*?}");
            string[] allTalents = new string[coll.Count];
            for (int i = 0; i < coll.Count; ++i)
                allTalents[i] = coll[i].Value;

            foreach (string strTalent in allTalents)
            {
                TalentData talent = new TalentData();
                talent.ID = strTalent.Between("\"id\":", ",");
                talent.Name = strTalent.Between("\"name\":\"", "\",").Trim('\'', '"').Replace("<NYI>", "").Replace("[NYI]", "").Replace("(NYI)", "").Replace("{NYI}", "");
                talent.Icon = strTalent.Between("\"icon\":\"", "\",");
                if (string.IsNullOrWhiteSpace(talent.Name)) continue;
                talent.MaxPoints = 1;
                talent.Row = int.Parse(strTalent.Between("\"tier\":", "}")) + 1;
                talent.Column = int.Parse(strTalent.Between("\"column\":", ",")) + 1;
                talent.Description = new string[1] { strTalent.Between("\"description\":\"", "\",").Replace("<span style=\\\"color:#8282FF\\\">", "").Replace("<span style=\\\"color:#FFFFFF\\\">", "").Replace("</span>", "").Trim('\'', '"') };
                talents.Add(talent);
            }

            talents = talents.OrderBy(talent => talent.Tree * 1000 + talent.Row * 10 + talent.Column * 1).ToList();
            int index = 0;
            foreach (var talent in talents)
                talent.Index = index++;
            foreach (var talent in talents.Where(t => t.Prerequisite > 0))
                talent.Prerequisite = talents.First(t => t.ID == talent.Prerequisite.ToString()).Index;

            //Generaete the code
            string className = classData.Name + "Talents";
            StringBuilder code = new StringBuilder();
            code.AppendFormat(
@"	public partial class {0} : TalentsBase
	{{
		public override TalentsBase Clone()
		{{
			{0} clone = ({0})MemberwiseClone();
			clone._data = (int[])_data.Clone();
			clone._glyphData = (bool[])_glyphData.Clone();
			clone.TreeCounts = new int[] {{ -1, -1, -1 }};
			return clone;
		}}
", className);
            code.Append("\r\n");
            code.AppendFormat("		private int[] _data = new int[{0}];\r\n", talents.Count);
            code.Append("		public override int[] Data { get { return _data; } }\r\n");
            code.AppendFormat("		public {0}() {{ }}\r\n", className);
            code.AppendFormat("		public {0}(string talents, int[][] glyphEncodes=null)\r\n", className);
            code.Append("		{\r\n");
            code.Append("			LoadString(talents, glyphEncodes);\r\n");
            code.Append("		}\r\n");
            code.Append("		public static string[] TreeNames = new [] {");
            foreach (string tree in classData.TreeNames)
                code.AppendFormat("\r\n			@\"{0}\",", tree);
            code.Append("};\r\n\r\n");
            int lasttree = -1;
            foreach (TalentData talent in talents)
            {
                if (lasttree == -1)
                {
                    lasttree = 0;
                    code.Append(string.Format("		#region {0}\r\n", classData.TreeNames[lasttree]));
                    code.Append("		public override int TreeStartingIndexes_" + lasttree.ToString() + " { get { return " + talent.Index.ToString() + "; } }\r\n");
                }
                else if (lasttree == 0 && talent.Tree == 1)
                {
                    lasttree = 1;
                    code.Append("		#endregion\r\n");
                    code.Append(string.Format("		#region {0}\r\n", classData.TreeNames[lasttree]));
                    code.Append("		public override int TreeStartingIndexes_" + lasttree.ToString() + " { get { return " + talent.Index.ToString() + "; } }\r\n");
                }
                else if (lasttree == 1 && talent.Tree == 2)
                {
                    lasttree = 2;
                    code.Append("		#endregion\r\n");
                    code.Append(string.Format("		#region {0}\r\n", classData.TreeNames[lasttree]));
                    code.Append("		public override int TreeStartingIndexes_" + lasttree.ToString() + " { get { return " + talent.Index.ToString() + "; } }\r\n");
                }
                code.Append(GenerateComment(talent));
                code.AppendFormat("\r\n[TalentData(index: {0}, name: \"{1}\", maxPoints: {2}, icon: \"{3}\",\r\n tree: {4}, column: {5}, row: {6}, prerequisite: {7}, description: new [] {{",
                    talent.Index, talent.Name, talent.MaxPoints, talent.Icon, talent.Tree, talent.Column, talent.Row, talent.Prerequisite == 0 ? -1 : talent.Prerequisite);
                foreach (string descRank in talent.Description)
                {
                    //strip html breaks from descriptions
                    string description = descRank.Replace("\\n", "\r\n");
                    code.AppendFormat("\r\n@\"{0}\",", description);
                }
                code.Append("})]\r\n");
                code.AppendFormat("public int {0} {{ get {{ return _data[{1}]; }} set {{ _data[{1}] = value; }} }}\r\n",
                    PropertyFromName(talent.Name), talent.Index);
            }
            code.Append("		#endregion\r\n");
            code.Append("	}\r\n\r\n");

            textBoxCode.Text += code.ToString();
        }

        /// <summary>
        /// Generate a comment for the talent field, based on it's description( Replaceed changed value by [BaseNumber * Pts])
        /// </summary>
        /// <param name="Talent">Given talent</param>
        /// <returns>The comment</returns>
        private string GenerateComment(TalentData Talent)
        {
            string Comment = Talent.Description[0];

            Comment = @"/// <summary>" + Environment.NewLine +
                      @"/// " + Comment.Replace("\r\n", "\r\n/// ") + Environment.NewLine +
                      @"/// </summary>";
            return Comment;
        }

        /// <summary>
        /// Returns a new string in which first occurrences of a specified string after position in this input string are replaced with another specified string.
        /// </summary>
        /// <param name="Text">Input string</param>
        /// <param name="OldValue">A string to be replaced</param>
        /// <param name="NewValue">A string to replace first occurrences of OldValue</param>
        /// <param name="Position">The starting character position, after wich, first occurences be replaced. 
        /// When this method returns, contains the 32-bit signed integer value, indicates the position, after replaced string  </param>
        /// <returns>A String equivalent to the input string but with first instance of OldValue replaced with NewValue</returns>
        private string Replace(string Text, string OldValue, string NewValue, ref int Position)
        {
            int NewPosition = Text.IndexOf(OldValue, Position);
            string Res = Text.Substring(0, NewPosition) + NewValue + Text.Substring(NewPosition + OldValue.Length);

            Position = NewPosition + NewValue.Length;
            return Res;
        }

        private string PropertyFromName(string name)
        {
            name = name.Replace("'", ""); // don't camel word after apostrophe
            string[] arr = name.Split(new char[] { ' ', ',', ':', '(', ')', '.', '-', '!' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < arr.Length; i++)
            {
                arr[i] = Char.ToUpperInvariant(arr[i][0]) + arr[i].Substring(1);
            }
            return string.Join("", arr);
        }

        private class TalentData
        {
            public string ID { get; set; }
            public int Index { get; set; }
            public string Name { get; set; }
            public int MaxPoints { get; set; }
            public int Tree { get; set; }
            public int Column { get; set; }
            public int Row { get; set; }
            public string Icon { get; set; }
            public int Prerequisite { get; set; }
            public string[] Description { get; set; }
        }

        private class ClassData
        {
            public int ID { get; set; }
            public string Name { get; set; }
            public string[] TreeNames { get; set; }
            public string[] TreeIDs { get; set; }
        }
    }
}
