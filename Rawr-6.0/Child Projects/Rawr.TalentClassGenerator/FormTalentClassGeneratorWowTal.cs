using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.IO;
using System.Xml;
using System.Globalization;
using System.Web.Script.Serialization;
using System.Text.RegularExpressions;
using System.Linq;

namespace Rawr.TalentClassGenerator
{
	public partial class FormTalentClassGeneratorWowTal : Form
	{
		public FormTalentClassGeneratorWowTal()
		{
			InitializeComponent();
		}

		private void buttonGenerateCode_Click(object sender, EventArgs e)
		{
            textBoxCode.Text = @"using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace Rawr
{
    /// <summary>
    /// This file is automatically generated by the Rawr.TalentClassGenerator tool. Please don't edit it directly.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property, Inherited = false, AllowMultiple = false)]
    public sealed class TalentDataAttribute : Attribute
    {
        public TalentDataAttribute(int index, string name, int column, int row, string description, string icon)
        {
            _index = index;
            _name = name;
            _column = column;
            _row = row;
            _description = description;
            _icon = icon;
        }

        private readonly int _index;
        private readonly string _name;
        private readonly int _column;
        private readonly int _row;
        private readonly string _icon;
        private readonly string _description;

        public int Index { get { return _index; } }
        public string Name { get { return _name; } }
        public int Column { get { return _column; } }
        public int Row { get { return _row; } }
        public string Description { get { return _description; } }
        public string Icon { get { return _icon; } }
    }

    public abstract class TalentsBase
    {
        public abstract bool[] Data { get; }
        public virtual bool[] GlyphData { get { return null; } }
        public int Specialization { get; set; }
        public string SpecializationName { get { return SpecializationNames[Specialization]; } set { Specialization = Array.IndexOf(SpecializationNames, value); } }
        public abstract string[] SpecializationNames { get; }
        //
        public virtual int GlyphTreeStartingIndexes_0 { get { return 0; } }
        public virtual int GlyphTreeStartingIndexes_1 { get { return 0; } }
        public virtual int GlyphTreeStartingIndexes_2 { get { return 0; } }
        public int[] GlyphTreeStartingIndexes { get { return new int[] { GlyphTreeStartingIndexes_0, GlyphTreeStartingIndexes_1, GlyphTreeStartingIndexes_2 }; } }
        public int[] GlyphTreeLengths
        {
            get
            {
                return new int[] {
                    GlyphTreeStartingIndexes_1,
                    GlyphTreeStartingIndexes_2 - GlyphTreeStartingIndexes_1,
                    GlyphData.Length - GlyphTreeStartingIndexes_2,
                };
            }
        }
        public int talentCount = -1;
        public int[] glyphtreeCounts = { -1, -1, -1 };
        //
        public int TalentCount
        {
            get
            {
                if (talentCount == -1)
                {
                    talentCount = 0;
                    for (int i = 0; i < 21; ++i)
                        if (Data[i]) ++talentCount;
                }
                return talentCount;
            }
            protected set { talentCount = value; }
        }
        public int[] GlyphTreeCounts
        {
            get
            {
                if (glyphtreeCounts[0] == -1)
                {
                    glyphtreeCounts[0] = 0;
                    for (int i = GlyphTreeStartingIndexes[0]; i < GlyphTreeStartingIndexes[1]; i++)
                    {
                        glyphtreeCounts[0] += GlyphData[i] ? 1 : 0;
                    }
                }
                if (glyphtreeCounts[1] == -1)
                {
                    glyphtreeCounts[1] = 0;
                    for (int i = GlyphTreeStartingIndexes[1]; i < GlyphTreeStartingIndexes[2]; i++)
                    {
                        glyphtreeCounts[1] += GlyphData[i] ? 1 : 0;
                    }
                }
                if (glyphtreeCounts[2] == -1)
                {
                    glyphtreeCounts[2] = 0;
                    for (int i = GlyphTreeStartingIndexes[2]; i < GlyphData.Length; i++)
                    {
                        glyphtreeCounts[2] += GlyphData[i] ? 1 : 0;
                    }
                }
                return glyphtreeCounts;
            }
            protected set { glyphtreeCounts = value; }
        }
        //
        protected void LoadString(string code, int[][] glyphEncodes = null)
        {
            if (string.IsNullOrEmpty(code)) return;
            bool[] _data = Data;
            string[] tmp = code.Split('.');
            int offset = 0;
            if (tmp[0].Length == 1)
            {
                Specialization = int.Parse(tmp[0]);
                offset = 1;
            }            
            string talents = tmp[offset];
            if (talents.Length >= _data.Length)
            {
                List<bool> data = new List<bool>();
                foreach (Char digit in talents)
                    data.Add(int.Parse(digit.ToString()) == 1);
                data.CopyTo(0, _data, 0, _data.Length);
            }
            if (tmp.Length > 1 + offset)
            {
                string glyphs = tmp[1 + offset];
                bool[] _glyphData = GlyphData;
                if (_glyphData != null && glyphs.Length == _glyphData.Length)
                {
                    List<bool> data = new List<bool>();
                    foreach (Char digit in glyphs)
                        data.Add(int.Parse(digit.ToString()) == 1);
                    data.CopyTo(_glyphData);
                }
            }
            else if (glyphEncodes != null)
            {
                // This makes it determine the glyphs active from WowHead Glyph IDs
                // (numbered as [0-2][0-5]), see TalentPicker.xaml.cs for details
                bool[] _glyphData = GlyphData;
                if (_glyphData != null)
                {
                    List<GlyphDataAttribute> glyphsInOrder_Prime = new List<GlyphDataAttribute>();
                    List<GlyphDataAttribute> glyphsInOrder_Major = new List<GlyphDataAttribute>();
                    List<GlyphDataAttribute> glyphsInOrder_Minor = new List<GlyphDataAttribute>();
                    foreach (PropertyInfo pi in this.GetType().GetProperties())
                    {
                        GlyphDataAttribute[] glyphDatas = pi.GetCustomAttributes(typeof(GlyphDataAttribute), true) as GlyphDataAttribute[];
                        if (glyphDatas.Length > 0)
                        {
                            if (glyphDatas[0].Type == GlyphType.Prime) { glyphsInOrder_Prime.Add(glyphDatas[0]); }
                            else if (glyphDatas[0].Type == GlyphType.Major) { glyphsInOrder_Major.Add(glyphDatas[0]); }
                            else if (glyphDatas[0].Type == GlyphType.Minor) { glyphsInOrder_Minor.Add(glyphDatas[0]); }
                        }
                    }
                    glyphsInOrder_Prime.Sort(CompareGlyphsById);
                    glyphsInOrder_Major.Sort(CompareGlyphsById);
                    glyphsInOrder_Minor.Sort(CompareGlyphsById);
                    int counter = 0;
                    for (int i = 0; i < glyphsInOrder_Prime.Count; i++)
                    {
                        for (int e = 0; e < 3; e++)
                        {
                            if (counter == glyphEncodes[0][e]) { _glyphData[glyphsInOrder_Prime[i].Index] = true; break; }
                        }
                        // Iterate Counter, but we can't do 6-9 of any 10 block
                        counter++;
                        if (counter == 6 || counter == 16 || counter == 26) { counter -= 6; counter += 10; }
                    }
                }
            }
        }

        private static int CompareGlyphsById(GlyphDataAttribute x, GlyphDataAttribute y)
        {
            if (x == null)
            {
                if (y == null)
                {
                    // If x is null and y is null, they're equal
                    return 0;
                }
                else
                {
                    // If x is null and y is not null, y is greater
                    return -1;
                }
            }
            else
            {
                // If x is not null...
                if (y == null)
                { // ...and y is null, x is greater.
                    return 1;
                }
                else
                {
                    // sort them with ordinary string comparison.
                    return x.SpellID.CompareTo(y.SpellID);
                }
            }
        }
        //
        public override string ToString()
        {
            StringBuilder ret = new StringBuilder();
            ret.Append(Specialization.ToString());
            ret.Append('.');
            foreach (bool digit in Data)
                ret.Append(digit ? '1' : '0');
            if (GlyphData != null)
            {
                ret.Append('.');
                foreach (bool glyph in GlyphData)
                {
                    ret.Append(glyph ? '1' : '0');
                }
            }
            return ret.ToString();
        }

        public CharacterClass GetClass()
        {
            if (GetType() == typeof(WarlockTalents)) return CharacterClass.Warlock;
            if (GetType() == typeof(MageTalents)) return CharacterClass.Mage;
            if (GetType() == typeof(PriestTalents)) return CharacterClass.Priest;
            if (GetType() == typeof(DruidTalents)) return CharacterClass.Druid;
            if (GetType() == typeof(RogueTalents)) return CharacterClass.Rogue;
            if (GetType() == typeof(HunterTalents)) return CharacterClass.Hunter;
            if (GetType() == typeof(ShamanTalents)) return CharacterClass.Shaman;
            if (GetType() == typeof(DeathKnightTalents)) return CharacterClass.DeathKnight;
            if (GetType() == typeof(PaladinTalents)) return CharacterClass.Paladin;
            return CharacterClass.Warrior;
        }

        public abstract TalentsBase Clone();
    }

";
			List<ClassData> classes = new List<ClassData>();
			classes.Add(new ClassData()
			{
				ID = 1,
				Name = "Warrior"
			});
			classes.Add(new ClassData()
			{
				ID = 2,
				Name = "Paladin"
			});
			classes.Add(new ClassData()
			{
				ID = 3,
				Name = "Hunter"
			});
			classes.Add(new ClassData()
			{
				ID = 4,
				Name = "Rogue"
			});
			classes.Add(new ClassData()
			{
				ID = 5,
				Name = "Priest"
			});
			classes.Add(new ClassData()
			{
				ID = 6,
				Name = "DeathKnight"
			});
			classes.Add(new ClassData()
			{
				ID = 7,
				Name = "Shaman"
			});
			classes.Add(new ClassData()
			{
				ID = 8,
				Name = "Mage"
			});
			classes.Add(new ClassData()
			{
				ID = 9,
				Name = "Warlock"
            });
            classes.Add(new ClassData()
            {
                ID = 10,
                Name = "Monk"
            });
			classes.Add(new ClassData()
			{
				ID = 11,
				Name = "Druid"
			});

			foreach (ClassData classData in classes)
			{
                string read = "";
                try
                {
                    var request = System.Net.HttpWebRequest.Create(
                        string.Format("http://www.wowdb.com/api/talents-wod?class={0}",
                        classData.ID));
                    using (var response = request.GetResponse())
                    {
                        read = new StreamReader(response.GetResponseStream()).ReadToEnd();
                        ClassResponse objResponse = (ClassResponse)new JavaScriptSerializer().Deserialize(read.Substring(1, read.Length - 2), typeof(ClassResponse));
                        ProcessTalentDataJSON(objResponse, classData);
                    }
                }
                catch (ProcessingException)
                {
                    return;
                }
                catch (Exception ex)
                {
                    textBoxCode.Text = "FAILED on: " + classData.Name + " : " + ex.Message + "\r\n\r\n" + ex.StackTrace + "\r\n\r\n" + read;
                    textBoxUrl.Text = (int.Parse(textBoxUrl.Text) - 1).ToString();
                    return;
                }
			}
            textBoxCode.Text += "}\r\n";
			textBoxCode.SelectAll();
			textBoxCode.Focus();
		}

		private void ProcessTalentDataJSON(ClassResponse responseData, ClassData classData)
		{
			List<TalentData> talents = new List<TalentData>();

            foreach (KeyValuePair<string, Dictionary<string, TalentData>> kvp in responseData.Talents)
            {
                int rowIndex = Convert.ToInt32(kvp.Key);
                foreach (KeyValuePair<string, TalentData> kvp2 in kvp.Value)
                {
                    TalentData data = kvp2.Value;

                    data.Row = rowIndex;
                    data.Column = Convert.ToInt32(kvp2.Key);

                    GetTalentDetails(data);

                    talents.Add(data);
                }
            }
			
			//Generaete the code
			string className = classData.Name + "Talents";
			StringBuilder code = new StringBuilder();
			code.AppendFormat(
@"	public partial class {0} : TalentsBase
	{{
        public override TalentsBase Clone()
        {{
            {0} clone = ({0})MemberwiseClone();
            clone._data = (bool[])_data.Clone();
            clone._glyphData = (bool[])_glyphData.Clone();
            clone.TalentCount = -1;
            return clone;
        }}

        private bool[] _data = new bool[21];
        public override bool[] Data {{ get {{ return _data; }} }}
        public {0}() {{ }}
        public {0}(string talents, int[][] glyphEncodes = null)
        {{
            LoadString(talents, glyphEncodes);
        }}
", className);

            code.AppendFormat(@"
        private static string[] specializationNames = new[] {{
			@""{0}"",@""{1}"",@""{2}""}};
        public override string[] SpecializationNames
        {{
            get {{ return specializationNames; }}
        }}
", responseData.Specializations["0"].Name, responseData.Specializations["1"].Name, responseData.Specializations["2"].Name);

            code.AppendFormat("     #region {0}\r\n", classData.Name);

            int index = 0;

			foreach (TalentData talent in talents)
			{
                code.Append(GenerateComment(talent));
                code.Append("\r\n");
                code.AppendFormat("[TalentData(index: {0}, name: \"{1}\", icon: \"{2}\",\r\n column: {3}, row: {4},\r\n description: @\"{5}\")]",
                    index, talent.Name, talent.Icon, talent.Column, talent.Row, talent.Description);
				code.AppendFormat("public bool {0} {{ get {{ return _data[{1}]; }} set {{ _data[{1}] = value; }} }}\r\n",
					PropertyFromName(talent.Name), index);
                ++index;
			}
            code.Append("		#endregion\r\n");
            code.Append("	}\r\n\r\n");

			textBoxCode.Text += code.ToString();
		}

        private void GetTalentDetails(TalentData data)
        {
            string read = "";
            try
            {
                if (Convert.ToInt32(data.ID) > 0)
                {
                    var request = System.Net.HttpWebRequest.Create(
                        string.Format("http://www.wowdb.com/spells/{0}",
                        data.ID));
                    using (var response = request.GetResponse())
                    {
                        read = new StreamReader(response.GetResponseStream()).ReadToEnd();
                        HtmlAgilityPack.HtmlDocument doc = new HtmlAgilityPack.HtmlDocument();
                        doc.LoadHtml(read);
                        HtmlAgilityPack.HtmlNode node = doc.DocumentNode.SelectSingleNode("//div[@class='db-image']").SelectSingleNode(".//img");
                        string source = node.Attributes["src"].Value;
                        if (!string.IsNullOrEmpty(source))
                        {
                            data.Icon = source.Substring(source.LastIndexOf("/") + 1);
                            data.Icon = data.Icon.Substring(0, data.Icon.IndexOf("."));
                        }
                        node = doc.DocumentNode.SelectSingleNode("//p[@class='yellow']");
                        data.Description = node.InnerText;
                    }
                }
                else
                {
                    var request = System.Net.HttpWebRequest.Create(
                        string.Format("http://www.wowdb.com/wod-talents/{0}/tooltip?advanced=1",
                        -Convert.ToInt32(data.ID)));
                    using (var response = request.GetResponse())
                    {
                        read = new StreamReader(response.GetResponseStream()).ReadToEnd();
                        dynamic wodTalent = new JavaScriptSerializer().DeserializeObject(read.Substring(1, read.Length - 2));
                        string html = wodTalent["Tooltip"];
                        HtmlAgilityPack.HtmlDocument doc = new HtmlAgilityPack.HtmlDocument();
                        doc.LoadHtml(html);
                        HtmlAgilityPack.HtmlNode node = doc.DocumentNode.SelectSingleNode("//div[@class='db-image']").SelectSingleNode(".//img");
                        string source = node.Attributes["src"].Value;
                        if (!string.IsNullOrEmpty(source))
                        {
                            data.Icon = source.Substring(source.LastIndexOf("/") + 1);
                            data.Icon = data.Icon.Substring(0, data.Icon.IndexOf("."));
                        }
                        node = doc.DocumentNode.SelectSingleNode("//p[@class='yellow']");
                        data.Description = node.InnerText;
                    }
                }
            }
            catch (Exception ex)
            {
                textBoxCode.Text = "FAILED on: " + data.Name + " : " + ex.Message + "\r\n\r\n" + ex.StackTrace + "\r\n\r\n" + read;
                textBoxUrl.Text = (int.Parse(textBoxUrl.Text) - 1).ToString();
                throw new ProcessingException(ex);
            }
        }

        private static IEnumerable<HtmlElement> GetElementsByClass(HtmlDocument doc, string className)
        {
            foreach (HtmlElement element in doc.All)
                if (element.GetAttribute("classname") == className)
                    yield return element;
        }

		/// <summary>
		/// Generate a comment for the talent field, based on it's description( Replaceed changed value by [BaseNumber * Pts])
		/// </summary>
		/// <param name="Talent">Given talent</param>
		/// <returns>The comment</returns>
		private string GenerateComment(TalentData Talent)
		{
            string Comment = Talent.Description;

			Comment = @"/// <summary>" + Environment.NewLine +
                      @"/// " + Regex.Replace(Comment.Replace("\r\n", "\r\n/// ").Replace("&nbsp;", " "), @"\.(\w)", ".\r\n/// $1") + Environment.NewLine +
					  @"/// </summary>";
			return Comment;
		}

		private string PropertyFromName(string name)
		{
			name = name.Replace("'", ""); // don't camel word after apostrophe
			string[] arr = name.Split(new char[] { ' ', ',', ':', '(', ')', '.', '-','!' }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < arr.Length; i++)
			{
				arr[i] = Char.ToUpperInvariant(arr[i][0]) + arr[i].Substring(1);
			}
			return string.Join("", arr);
		}

        private class ClassResponse
        {
            public int NumSpecializations { get; set; }
            public Dictionary<string, Dictionary<string, TalentData>> Talents { get; set; }
            public Dictionary<string, SpecData> Specializations { get; set; }
            public Dictionary<string, SpellData> Spells { get; set; }
            public List<List<GlyphData>> Glyphs { get; set; }
        }

		private class TalentData
		{
			public string ID { get; set; }
			public string Name { get; set; }
            public int Column { get; set; }
            public int Row { get; set; }
            public string Icon { get; set; }
			public string Description { get; set; }
		}

        private class SpecData
        {
            public string Name { get; set; }
            public string Description { get; set; }
            public string Role { get; set; }
        }

        private class SpellData
        {
            public int ID { get; set; }
            public int Level { get; set; }
            public string Name { get; set; }
            public int Spec { get; set; }
        }

        private class GlyphData
        {
            public int ID { get; set; }
            public string Name { get; set; }
            public string Description { get; set; }
            public int SpriteOffset { get; set; }
        }

		private class ClassData
		{
			public int ID { get; set; }
			public string Name { get; set; }
		}

        private class ProcessingException : Exception
        {
            public ProcessingException(Exception innerEx) : base("Processing exception retreiving talent details", innerEx) { }
        }
	}
}
